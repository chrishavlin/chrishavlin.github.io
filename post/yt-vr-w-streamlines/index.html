<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.81.0"><title>Adding streamlines to a volume rendering in yt &#183; Chris Havlin</title><meta name=description content><meta itemprop=name content="Adding streamlines to a volume rendering in yt"><meta itemprop=description content="I recently fielded a question on the yt slack about adding streamlines to a volume rendering in yt and decided it was worth documenting the solution a bit more!"><meta itemprop=datePublished content="2023-11-08T10:13:08-06:00"><meta itemprop=dateModified content="2023-11-08T10:13:08-06:00"><meta itemprop=wordCount content="1040"><meta itemprop=image content="https://chrishavlin.github.io/images/turt.png"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chrishavlin.github.io/images/turt.png"><meta name=twitter:title content="Adding streamlines to a volume rendering in yt"><meta name=twitter:description content="I recently fielded a question on the yt slack about adding streamlines to a volume rendering in yt and decided it was worth documenting the solution a bit more!"><meta property="og:title" content="Adding streamlines to a volume rendering in yt"><meta property="og:description" content="I recently fielded a question on the yt slack about adding streamlines to a volume rendering in yt and decided it was worth documenting the solution a bit more!"><meta property="og:type" content="article"><meta property="og:url" content="https://chrishavlin.github.io/post/yt-vr-w-streamlines/"><meta property="og:image" content="https://chrishavlin.github.io/images/turt.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-11-08T10:13:08-06:00"><meta property="article:modified_time" content="2023-11-08T10:13:08-06:00"><meta property="og:site_name" content="Chris Havlin"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://chrishavlin.github.io/#author","name":null,"image":{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png"},"description":" "},{"@type":"WebSite","@id":"https://chrishavlin.github.io/#website","url":"https://chrishavlin.github.io/","name":"Chris Havlin","description":" ","publisher":{"@id":"https://chrishavlin.github.io/#author"},"inLanguage":"en"},{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png","caption":"Chris Havlin"},{"@type":"WebPage","@id":"https://chrishavlin.github.io/post/yt-vr-w-streamlines/#webpage","url":"https://chrishavlin.github.io/post/yt-vr-w-streamlines/","name":"Adding streamlines to a volume rendering in yt","isPartOf":{"@id":"https://chrishavlin.github.io/#website"},"about":{"@id":"https://chrishavlin.github.io/#author"},"datePublished":"2023-11-08T10:13:08-06:00","dateModified":"2023-11-08T10:13:08-06:00","description":"I recently fielded a question on the yt slack about adding streamlines to a volume rendering in yt and decided it was worth documenting the solution a bit more!","inLanguage":"en","potentialAction":[{"@type":"ReadAction","target":["https://chrishavlin.github.io/post/yt-vr-w-streamlines/"]}]},{"@type":"Article","isPartOf":{"@id":"https://chrishavlin.github.io/post/yt-vr-w-streamlines/#webpage"},"mainEntityOfPage":{"@id":"https://chrishavlin.github.io/post/yt-vr-w-streamlines/#webpage"},"headline":"Adding streamlines to a volume rendering in yt","datePublished":"2023-11-08T10:13:08-06:00","dateModified":"2023-11-08T10:13:08-06:00","publisher":{"@id":"https://chrishavlin.github.io/#author"},"keywords":[],"articleSection":[],"inLanguage":"en","author":{"@type":"Person","name":null},"potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https://chrishavlin.github.io/post/yt-vr-w-streamlines/#comments"]}]}]}</script><link type=text/css rel=stylesheet href=/css/print.css media=print><link type=text/css rel=stylesheet href=/css/poole.css><link type=text/css rel=stylesheet href=/css/hyde.css><style type=text/css>.sidebar{background-color:#3b7044}.read-more-link a{border-color:#3b7044}.read-more-link a:hover{background-color:#3b7044}.pagination li a{color:#3b7044;border:1px solid #3b7044}.pagination li.active a{background-color:#3b7044}.pagination li a:hover{background-color:#3b7044;opacity:.75}footer a,.content a,.related-posts li a:hover{color:#3b7044}</style><link type=text/css rel=stylesheet href=/css/blog.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class=container><div class=sidebar-about><div class=author-image><a href=https://chrishavlin.github.io/><img src=/images/turt.png class="img-circle img-headshot center" alt="Profile Picture"></a></div><h1>Chris Havlin</h1><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://chrishavlin.github.io/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav><section class=social-icons><a href=https://github.com/chrishavlin rel=me title=GitHub target=_blank><i class="fab fa-github" aria-hidden=true></i></a><a href=https://twitter.com/s_i_r_h_c rel=me title=@s_i_r_h_c target=_blank><i class="fab fa-twitter" aria-hidden=true></i></a><a href=https://www.instagram.com/chrishavlin/ rel=me title=@chrishavlin target=_blank><i class="fab fa-instagram" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/christopherhavlin/ rel=me title=Linkedin target=_blank><i class="fab fa-linkedin" aria-hidden=true></i></a></section></div></aside><main class="content container"><div class=post><h1 class=title>Adding streamlines to a volume rendering in yt</h1><div class=post-date><time datetime=2023-11-08T10:13:08-0600>Nov 8, 2023</time> <span class=readtime>&#183; 5 min read</span></div><div><p>I recently fielded a question on the yt slack about adding streamlines to a volume rendering in yt and decided it was worth documenting the solution a bit more!</p><h3 id=rendersource-objects-in-yts-volume-rendering><code>RenderSource</code> objects in yt&rsquo;s volume rendering</h3><p>Let&rsquo;s start with an overview of the different representations of data in the volume rendering API in yt. The <code>render_source</code> module:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>yt<span style=color:#f92672>.</span>visualization<span style=color:#f92672>.</span>volume_rendering<span style=color:#f92672>.</span>render_source<span style=color:#960050;background-color:#1e0010>`</span>
</code></pre></div><p>has a number of objects for different data types based on a common <code>RenderSource</code> object that determines how the 3D rendering engine sample and composite data. The <code>RenderSource</code> types are divided into <code>OpaqueSource</code> and <code>VolumeSource</code> objects:</p><p><img src=/images/yt-vr-w-streamlines/render_source.png alt=png></p><p>The <code>VolumeSource</code> objects (usually initialized via the <code>create_volume_source</code> function) are the volume rendering components while the <code>OpaqueSource</code> objects are additional annotations.</p><p>As a quick aside, the above graph was generated with the <a href=https://github.com/data-exp-lab/inheritance_explorer><code>inheritance-explorer</code> (link)</a> package:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> inheritance_explorer <span style=color:#f92672>as</span> ie
<span style=color:#f92672>from</span> yt.visualization.volume_rendering.render_source <span style=color:#f92672>import</span> RenderSource
rs <span style=color:#f92672>=</span> ie<span style=color:#f92672>.</span>ClassGraphTree(RenderSource)
g <span style=color:#f92672>=</span> rs<span style=color:#f92672>.</span>graph(ratio<span style=color:#f92672>=.</span><span style=color:#ae81ff>4</span>)
g<span style=color:#f92672>.</span>write_png(<span style=color:#e6db74>&#39;RenderSources.png&#39;</span>)
</code></pre></div><h3 id=building-curves-with-linesource-objects>Building curves with <code>LineSource</code> objects</h3><p>So to add streamlines, we&rsquo;ll want to use the <code>LineSource</code> in particular. This let&rsquo;s you add lines, specified by start and end points to a volume rendering scene. The tricky part is that to we&rsquo;ll need to split up our 3D curves into a series of line segments.</p><p>First, let&rsquo;s build a base volume rendering</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> yt
ds <span style=color:#f92672>=</span> yt<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#34;IsolatedGalaxy/galaxy0030/galaxy0030&#34;</span>)
sc <span style=color:#f92672>=</span> yt<span style=color:#f92672>.</span>create_scene(ds)
sc<span style=color:#f92672>.</span>camera<span style=color:#f92672>.</span>zoom(<span style=color:#ae81ff>3</span>)
sc<span style=color:#f92672>.</span>show(sigma_clip<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</code></pre></div><p><img src=/images/yt-vr-w-streamlines/iso_galaxy_v0.png alt=png></p><p>So to use the <code>LineSource</code>, we need to provide a list of start and end points. The yt docs demonstrate this with random lines (<a href=https://yt-project.org/doc/cookbook/complex_plots.html#volume-rendering-with-lines>link</a>), but we can also create a continuous curve by stitching together multiple line segments:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
vertices <span style=color:#f92672>=</span> []
vert <span style=color:#f92672>=</span> ([<span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0.5</span>], [<span style=color:#ae81ff>0.6</span>, <span style=color:#ae81ff>0.52</span>, <span style=color:#ae81ff>0.52</span>])
vertices<span style=color:#f92672>.</span>append(vert)
vert_2 <span style=color:#f92672>=</span> (vert[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0.3</span>, <span style=color:#ae81ff>0.2</span>, <span style=color:#ae81ff>0.48</span>])
vertices<span style=color:#f92672>.</span>append(vert_2)
vertices <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(vertices)
</code></pre></div><p>Note that we&rsquo;re simply setting the start of each consecutive line segment to the
end of the prior segment:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(vertices)
array([[[<span style=color:#ae81ff>0.5</span> , <span style=color:#ae81ff>0.5</span> , <span style=color:#ae81ff>0.5</span> ],
        [<span style=color:#ae81ff>0.6</span> , <span style=color:#ae81ff>0.52</span>, <span style=color:#ae81ff>0.52</span>]],

       [[<span style=color:#ae81ff>0.6</span> , <span style=color:#ae81ff>0.52</span>, <span style=color:#ae81ff>0.52</span>],
        [<span style=color:#ae81ff>0.3</span> , <span style=color:#ae81ff>0.2</span> , <span style=color:#ae81ff>0.48</span>]]])
</code></pre></div><p>Let&rsquo;s add this to our rendering:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>colors <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones([vertices<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>4</span>])    
colors[:, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
ls <span style=color:#f92672>=</span> LineSource(vertices, colors)    
sc<span style=color:#f92672>.</span>add_source(ls)
sc<span style=color:#f92672>.</span>render()
sc<span style=color:#f92672>.</span>show(sigma_clip<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</code></pre></div><p><img src=/images/yt-vr-w-streamlines/iso_galaxy_v1.png alt=png></p><p>To add a continuous curve, we&rsquo;ll take a our position array and split it into a
series of line segments (I&rsquo;m saying &ldquo;continuous&rdquo; here despite the fact that we&rsquo;re
still dealing with discrete positions&mldr; but if you sample at a high enough rate
the curves will look smooth).</p><p>So, let&rsquo;s create an arbitrary curve that we want to add. The following places a
circle in the x-y plane centered in the z plane:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
theta <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(<span style=color:#ae81ff>0</span>, np<span style=color:#f92672>.</span>pi<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>100</span>)
x <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>cos(theta) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
y <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(theta) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>
z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>full(x<span style=color:#f92672>.</span>shape, <span style=color:#ae81ff>0.5</span>)
pos <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>column_stack([x, y, z])
<span style=color:#66d9ef>print</span>(pos[:<span style=color:#ae81ff>3</span>])
</code></pre></div><pre><code>[[0.6        0.5        0.5       ]
 [0.59979867 0.50634239 0.5       ]
 [0.59919548 0.51265925 0.5       ]]
</code></pre><p>Now we&rsquo;ll write a function to take that position array and split it up into
a bunch of line segments.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>segment_a_curve</span>(pos_i):
    index_range <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, pos_i<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>])
    line_indices <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>column_stack([index_range, index_range])<span style=color:#f92672>.</span>ravel()[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]

    line_segments <span style=color:#f92672>=</span> pos_i[line_indices, :]
    n_line_segments <span style=color:#f92672>=</span> int(line_segments<span style=color:#f92672>.</span>size<span style=color:#f92672>/</span><span style=color:#ae81ff>6</span>)
    <span style=color:#66d9ef>return</span> line_segments<span style=color:#f92672>.</span>reshape((n_line_segments, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>))
segmented <span style=color:#f92672>=</span> segment_a_curve(pos)
</code></pre></div><p>All that fancy indexing simply creates a series of vertices like we had in the
simpler case, with the start points of each vertex being the end point of the prior:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(segmented[:<span style=color:#ae81ff>3</span>])
[[[<span style=color:#ae81ff>0.6</span>        <span style=color:#ae81ff>0.5</span>        <span style=color:#ae81ff>0.5</span>       ]
  [<span style=color:#ae81ff>0.59979867</span> <span style=color:#ae81ff>0.50634239</span> <span style=color:#ae81ff>0.5</span>       ]]

 [[<span style=color:#ae81ff>0.59979867</span> <span style=color:#ae81ff>0.50634239</span> <span style=color:#ae81ff>0.5</span>       ]
  [<span style=color:#ae81ff>0.59919548</span> <span style=color:#ae81ff>0.51265925</span> <span style=color:#ae81ff>0.5</span>       ]]

 [[<span style=color:#ae81ff>0.59919548</span> <span style=color:#ae81ff>0.51265925</span> <span style=color:#ae81ff>0.5</span>       ]
  [<span style=color:#ae81ff>0.59819287</span> <span style=color:#ae81ff>0.51892512</span> <span style=color:#ae81ff>0.5</span>       ]]]
</code></pre></div><p>while not ideal in that we&rsquo;re doubling the memory used for our curve, it does
let us add our curves&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>colors <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones([segmented<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>4</span>])    
colors[:, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
ls <span style=color:#f92672>=</span> LineSource(segmented, colors)    
sc<span style=color:#f92672>.</span>add_source(ls)
sc<span style=color:#f92672>.</span>render()
sc<span style=color:#f92672>.</span>show(sigma_clip<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</code></pre></div><p><img src=/images/yt-vr-w-streamlines/iso_galaxy_v2.png alt=png></p><h3 id=adding-streamlines>Adding streamlines</h3><p>Finally, we can get back to actually adding our streamlines. First, let&rsquo;s
calculate some streamline positions! The following function creates random starting
points within a radial distance of 0.1 to 0.2 from the domain center:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_streamline_starting_pos</span>(N):    
    c <span style=color:#f92672>=</span> ds<span style=color:#f92672>.</span>domain_center
    rng <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>default_rng()
    r <span style=color:#f92672>=</span> rng<span style=color:#f92672>.</span>uniform(low<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>, high<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>, size<span style=color:#f92672>=</span>(N,))
    theta <span style=color:#f92672>=</span> rng<span style=color:#f92672>.</span>uniform(low<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, high<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>np<span style=color:#f92672>.</span>pi, size<span style=color:#f92672>=</span>(N,))
    phi <span style=color:#f92672>=</span> rng<span style=color:#f92672>.</span>uniform(low<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, high<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>pi, size<span style=color:#f92672>=</span>(N,))

    z <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>cos(phi)
    xy <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(phi)
    x <span style=color:#f92672>=</span> xy <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>cos(theta)
    y <span style=color:#f92672>=</span> xy <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(theta)

    offset <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>column_stack([x, y, z])
    pos <span style=color:#f92672>=</span> c <span style=color:#f92672>+</span> ds<span style=color:#f92672>.</span>arr(offset, <span style=color:#e6db74>&#39;code_length&#39;</span>)
    <span style=color:#66d9ef>return</span> pos

pos <span style=color:#f92672>=</span> get_streamline_starting_pos(<span style=color:#ae81ff>10</span>)
</code></pre></div><p>To build our streamlines, we&rsquo;re going to first initialize an <code>AMRKDTree</code> &ndash; this
is simply to save time since we can re-use it when we re-calculate streamlines later on
and save some initialization time. You can skip this step if you don&rsquo;t mind waiting for the
KDTree to rebuild:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> yt.utilities.amr_kdtree.api <span style=color:#f92672>import</span> AMRKDTree

x_field <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;gas&#34;</span>, <span style=color:#e6db74>&#34;velocity_x&#34;</span>)
y_field <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;gas&#34;</span>, <span style=color:#e6db74>&#34;velocity_y&#34;</span>)
z_field <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;gas&#34;</span>, <span style=color:#e6db74>&#34;velocity_z&#34;</span>)

volume <span style=color:#f92672>=</span> AMRKDTree(ds)
volume<span style=color:#f92672>.</span>set_fields(
    [x_field, y_field, z_field], [False, False, False], False
)
volume<span style=color:#f92672>.</span>join_parallel_trees()
</code></pre></div><p>Aaaand now let&rsquo;s actually get those streamlines!!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>streamlines <span style=color:#f92672>=</span> Streamlines(
    ds,
    pos,
    x_field, y_field, z_field,
    length<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span> <span style=color:#f92672>*</span> Mpc,
    get_magnitude<span style=color:#f92672>=</span>True,
    volume<span style=color:#f92672>=</span>volume
)
streamlines<span style=color:#f92672>.</span>integrate_through_volume()
</code></pre></div><p>And create a new rendering&mldr; now we&rsquo;ll iterate through each streamline and
segment each one, create a line source and add it to the rendering:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sc <span style=color:#f92672>=</span> yt<span style=color:#f92672>.</span>create_scene(ds)
sc<span style=color:#f92672>.</span>camera<span style=color:#f92672>.</span>zoom(<span style=color:#ae81ff>3</span>)

<span style=color:#66d9ef>for</span> streamline <span style=color:#f92672>in</span> streamlines<span style=color:#f92672>.</span>streamlines:
    segmented_streamlines <span style=color:#f92672>=</span> segment_a_curve(streamline)
    colors <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones([segmented_streamlines<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>4</span>])    
    colors[:, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>
    ls <span style=color:#f92672>=</span> LineSource(segmented_streamlines, colors)    
    sc<span style=color:#f92672>.</span>add_source(ls)

sc<span style=color:#f92672>.</span>render()
sc<span style=color:#f92672>.</span>show(sigma_clip<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</code></pre></div><p><img src=/images/yt-vr-w-streamlines/iso_galaxy_v3.png alt=png></p><p>Woo! there it is.</p><p>When adding <code>OpaqueSource</code> objects, that alpha value can have a strong influence
on the final image. Up above, this is set to 0.01 &ndash; if it&rsquo;s higher then the lines
will tend to swamp out the volume rendering and you&rsquo;ll only see the streamlines.
This takes a bit of trial and error to get right.</p><p>And just for fun, let&rsquo;s try adding a bunch of streamlines. First, get our new
starting positions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>pos <span style=color:#f92672>=</span> get_streamline_starting_pos(<span style=color:#ae81ff>500</span>)
</code></pre></div><p>and now a new <code>Streamlines</code> object (using the same volume as before):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>streamlines <span style=color:#f92672>=</span> Streamlines(
    ds,
    pos,
    x_field, y_field, z_field,
    length<span style=color:#f92672>=</span><span style=color:#ae81ff>1.0</span> <span style=color:#f92672>*</span> Mpc,
    get_magnitude<span style=color:#f92672>=</span>True,
    volume<span style=color:#f92672>=</span>volume
)
</code></pre></div><p>and the integration (this step will take a while):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>streamlines<span style=color:#f92672>.</span>integrate_through_volume()
</code></pre></div><p>Now, let&rsquo;s rebuild our rendering again</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>sc <span style=color:#f92672>=</span> yt<span style=color:#f92672>.</span>create_scene(ds)
sc<span style=color:#f92672>.</span>camera<span style=color:#f92672>.</span>zoom(<span style=color:#ae81ff>3</span>)

<span style=color:#66d9ef>for</span> streamline <span style=color:#f92672>in</span> streamlines<span style=color:#f92672>.</span>streamlines:
    segmented_streamlines <span style=color:#f92672>=</span> segment_a_curve(streamline)
    colors <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>ones([segmented_streamlines<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>4</span>])    
    colors[:, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span>
    ls <span style=color:#f92672>=</span> LineSource(segmented_streamlines, colors)    
    sc<span style=color:#f92672>.</span>add_source(ls)

sc<span style=color:#f92672>.</span>render()
sc<span style=color:#f92672>.</span>show(sigma_clip<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</code></pre></div><p><img src=/images/yt-vr-w-streamlines/iso_galaxy_v4.png alt=png></p><h3 id=yt_idv->yt_idv ?</h3><p>As a final note, this is very similar to how I implemented the <a href=http://localhost:1313/post/yt-idv-streamlines/>streamline
functionality in yt_idv</a>! The index manipulation is pretty much identical and then the vertex positions are passed down to the GPU where OpenGL draws the lines.</p><h3 id=notebook>notebook</h3><p>For convenience, I dropped all the above code into a notebook, <a href=https://github.com/chrishavlin/yt_scratch/blob/master/notebooks/tutorials_etc/vol_render_with_curves.ipynb>available here</a>.</p></div><div class=share-buttons><a class=twitter-share-button href=# title="Share on Twitter" data-url=https://chrishavlin.github.io/post/yt-vr-w-streamlines/ data-text="Adding streamlines to a volume rendering in yt"><i class="fab fa-twitter"></i></a><a class=linkedin-share-button href=# title="Share on LinkedIn" data-url=https://chrishavlin.github.io/post/yt-vr-w-streamlines/ data-text="Adding streamlines to a volume rendering in yt"><i class="fab fa-linkedin-in"></i></a><a class=facebook-share-button href=# title="Share on Facebook" data-url=https://chrishavlin.github.io/post/yt-vr-w-streamlines/ data-text="Adding streamlines to a volume rendering in yt"><i class="fab fa-facebook"></i></a><a class=telegram-share-button href=# title="Share on Telegram" data-url=https://chrishavlin.github.io/post/yt-vr-w-streamlines/ data-text="Adding streamlines to a volume rendering in yt"><i class="fab fa-telegram"></i></a><a class=pinterest-share-button href=# title="Share on Pinterest" data-url=https://chrishavlin.github.io/post/yt-vr-w-streamlines/ data-text="Adding streamlines to a volume rendering in yt"><i class="fab fa-pinterest"></i></a></div></div></main><footer><div><p>&copy; Chris Havlin 2023
&#183; <a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank>CC BY-SA 4.0</a>
&#183; Build with <a href=https://gohugo.io/ target=_blank>Hugo</a> & <a href=https://themes.gohugo.io/soho/ target=_blank>Soho</a> theme</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin=anonymous></script><script src=/js/jquery.min.js></script><script src=/js/soho.js></script></body></html>