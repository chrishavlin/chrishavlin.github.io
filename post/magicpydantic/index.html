<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.81.0"><title>Autogeneration of magicgui-pydantic widgets &#183; Chris Havlin</title><meta name=description content><meta itemprop=name content="Autogeneration of magicgui-pydantic widgets"><meta itemprop=description content="This post describes a simple way of generating a magicgui widget from a pydantic model."><meta itemprop=datePublished content="2022-04-05T13:45:56-04:00"><meta itemprop=dateModified content="2022-04-05T13:45:56-04:00"><meta itemprop=wordCount content="1539"><meta itemprop=image content="https://chrishavlin.github.io/images/turt.png"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chrishavlin.github.io/images/turt.png"><meta name=twitter:title content="Autogeneration of magicgui-pydantic widgets"><meta name=twitter:description content="This post describes a simple way of generating a magicgui widget from a pydantic model."><meta property="og:title" content="Autogeneration of magicgui-pydantic widgets"><meta property="og:description" content="This post describes a simple way of generating a magicgui widget from a pydantic model."><meta property="og:type" content="article"><meta property="og:url" content="https://chrishavlin.github.io/post/magicpydantic/"><meta property="og:image" content="https://chrishavlin.github.io/images/turt.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-05T13:45:56-04:00"><meta property="article:modified_time" content="2022-04-05T13:45:56-04:00"><meta property="og:site_name" content="Chris Havlin"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://chrishavlin.github.io/#author","name":null,"image":{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png"},"description":" "},{"@type":"WebSite","@id":"https://chrishavlin.github.io/#website","url":"https://chrishavlin.github.io/","name":"Chris Havlin","description":" ","publisher":{"@id":"https://chrishavlin.github.io/#author"},"inLanguage":"en"},{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png","caption":"Chris Havlin"},{"@type":"WebPage","@id":"https://chrishavlin.github.io/post/magicpydantic/#webpage","url":"https://chrishavlin.github.io/post/magicpydantic/","name":"Autogeneration of magicgui-pydantic widgets","isPartOf":{"@id":"https://chrishavlin.github.io/#website"},"about":{"@id":"https://chrishavlin.github.io/#author"},"datePublished":"2022-04-05T13:45:56-04:00","dateModified":"2022-04-05T13:45:56-04:00","description":"This post describes a simple way of generating a magicgui widget from a pydantic model.","inLanguage":"en","potentialAction":[{"@type":"ReadAction","target":["https://chrishavlin.github.io/post/magicpydantic/"]}]},{"@type":"Article","isPartOf":{"@id":"https://chrishavlin.github.io/post/magicpydantic/#webpage"},"mainEntityOfPage":{"@id":"https://chrishavlin.github.io/post/magicpydantic/#webpage"},"headline":"Autogeneration of magicgui-pydantic widgets","datePublished":"2022-04-05T13:45:56-04:00","dateModified":"2022-04-05T13:45:56-04:00","publisher":{"@id":"https://chrishavlin.github.io/#author"},"keywords":[],"articleSection":[],"inLanguage":"en","author":{"@type":"Person","name":null},"potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https://chrishavlin.github.io/post/magicpydantic/#comments"]}]}]}</script><link type=text/css rel=stylesheet href=/css/print.css media=print><link type=text/css rel=stylesheet href=/css/poole.css><link type=text/css rel=stylesheet href=/css/hyde.css><style type=text/css>.sidebar{background-color:#3b7044}.read-more-link a{border-color:#3b7044}.read-more-link a:hover{background-color:#3b7044}.pagination li a{color:#3b7044;border:1px solid #3b7044}.pagination li.active a{background-color:#3b7044}.pagination li a:hover{background-color:#3b7044;opacity:.75}footer a,.content a,.related-posts li a:hover{color:#3b7044}</style><link type=text/css rel=stylesheet href=/css/blog.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class=container><div class=sidebar-about><div class=author-image><a href=https://chrishavlin.github.io/><img src=/images/turt.png class="img-circle img-headshot center" alt="Profile Picture"></a></div><h1>Chris Havlin</h1><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://chrishavlin.github.io/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav><section class=social-icons><a href=https://github.com/chrishavlin rel=me title=GitHub target=_blank><i class="fab fa-github" aria-hidden=true></i></a><a href=https://twitter.com/s_i_r_h_c rel=me title=@s_i_r_h_c target=_blank><i class="fab fa-twitter" aria-hidden=true></i></a><a href=https://www.instagram.com/chrishavlin/ rel=me title=@chrishavlin target=_blank><i class="fab fa-instagram" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/christopherhavlin/ rel=me title=Linkedin target=_blank><i class="fab fa-linkedin" aria-hidden=true></i></a></section></div></aside><main class="content container"><div class=post><h1 class=title>Autogeneration of magicgui-pydantic widgets</h1><div class=post-date><time datetime=2022-04-05T13:45:56-0400>Apr 5, 2022</time> <span class=readtime>&#183; 8 min read</span></div><div><p>This post describes a simple way of generating a magicgui widget from a pydantic model.</p><h2 id=background>Background</h2><p>For a little while now I&rsquo;ve been working on a new <a href=https://github.com/data-exp-lab/yt-napari>yt-napari plugin</a> which will create an interface for yt within napari (<a href=https://ischool.illinois.edu/news-events/news/2021/11/ischool-researchers-receive-funding-napari-plugin-project>background</a>). The initial phases of the project (1) built out a reader plugin that lets you load a json file specifying the information needed to load data from a yt dataset like fields and selections and (2) added some helper functions for adding yt layers to an active napari viewer from the notebook, taking care of properly aligning multiple layers in napari&rsquo;s image coordinates. Lately, though I&rsquo;ve been working on the final main piece for the initial release: a dockable widget for loading data.</p><p><a href=https://napari.org>Napari</a> provides some great ways of building out widgets, including the related <a href=https://napari.org/magicgui/>magicgui</a> package that helps to streamline widget creation. After playing around with building out simple widgets for data loading that allow the user to supply filenames, fields and other parameters, I turned to working out how to use the pydantic model that I already had for the reader plugin to generate a GUI plugin. In pseudo-code, my question was if I have some nested pydantic models:</p><pre><code>import pydantic


class Field(pydantic.BaseModel):
    field_type: str
    field_name: str
    
class DataModel(pydantic.BaseModel):
    file: str
    field: Field
    ... etc ... 
    
</code></pre><p>and I already have methods for ingesting a <code>DataModel</code> instance and returning a yt dataset, how do I create a magicgui widget that lets me set all those fields and return the yt dataset? It turns out that there actually is some work in progress to allow direct generation of widgets from pydantic models (<a href=https://github.com/napari/magicgui/pull/318>link</a>), but since my pydantic models are fairly straightforward it&rsquo;s actually not too bad to automate this myself until the magicgui devs formally implement it.</p><h2 id=requirements>requirements</h2><p>The tutorial here relies on <a href=https://github.com/napari/magicgui>magicgui</a> and <a href=https://pydantic-docs.helpmanual.io/>pydantic</a> installed. So go do that!</p><h2 id=magicgui-intro>magicgui intro</h2><p>Ok, so I&rsquo;ve not worked with widgets very much and there were a few things that I needed to work out that helped immensely. The magicgui intro (<a href=https://napari.org/magicgui/usage/quickstart.html>link</a>) is great, but I knew that my case would be too complex to work with the function-decorating &ndash; I needed to construct some gui classes with callbacks. But I was missing some basics&mldr; So first off, when you have a container widget:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> magicgui <span style=color:#f92672>import</span> widgets
container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()
</code></pre></div><p>and add another widget to that container, specifying the <code>name</code> parameter:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>SpinBox(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;x&#34;</span>))
</code></pre></div><p>then that new <code>SpinBox</code> widget is available as an attribute under <code>container</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(container<span style=color:#f92672>.</span>x)

    SpinBox(value<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, annotation<span style=color:#f92672>=</span>None, name<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;x&#39;</span>)
</code></pre></div><p>And to pop up a gui window, we do:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)
</code></pre></div><p>and get our little widget:</p><p><img src=/images/magicguipydantic/widgets_01.png alt=png></p><p>The second important bit is the mechanics of callbacks with magicgui. Most (all?) of the magicgui widgets have attributes that can be connected to callbacks. For example, the <code>SpinBox</code> that we added has a <code>.changed</code> attribute that will signal when the value is changed. So if we have a widget to display a result</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>Label(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;result&#34;</span>))
</code></pre></div><p>and a function that looks at the value of x and updates the display:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_result</span>():
    result <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>value <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
    c<span style=color:#f92672>.</span>result<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> f<span style=color:#e6db74>&#34;{result}&#34;</span> 
</code></pre></div><p>we can trigger that function with</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>container<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>changed<span style=color:#f92672>.</span>connect(calculate_result)
</code></pre></div><p>so now when we do</p><pre><code>container.show(run=True)
</code></pre><p>and change the value of <code>x</code>, we&rsquo;ll get:</p><p><img src=/images/magicguipydantic/widgets_02.png alt=png></p><p>Putting all the above snippets together:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> magicgui <span style=color:#f92672>import</span> widgets

container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>SpinBox(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;x&#34;</span>))
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>Label(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;result&#34;</span>))

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_result</span>():
    result <span style=color:#f92672>=</span> container<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>value <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
    container<span style=color:#f92672>.</span>result<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> f<span style=color:#e6db74>&#34;{result}&#34;</span> 
    
    
container<span style=color:#f92672>.</span>x<span style=color:#f92672>.</span>changed<span style=color:#f92672>.</span>connect(calculate_result)  
container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)  
</code></pre></div><p>The final piece needed is to understand a little of how magicgui does its magic. When you use the fancy magicgui function decorators, it checks the type of the arguments and returns an appropriate widget. I still want to make use of that here, but in a little more explicit manner. For that, we can use <code>get_widget_class</code>, which can accept a type and returns the widget that magicgui thinks you&rsquo;d want:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> magicgui.type_map <span style=color:#f92672>import</span> get_widget_class

get_widget_class(annotation <span style=color:#f92672>=</span> str)
(magicgui<span style=color:#f92672>.</span>widgets<span style=color:#f92672>.</span>LineEdit, {})
</code></pre></div><h2 id=pydantic--magicgui>pydantic & magicgui</h2><p>Given the above behavior of magicgui, the approach I arrived at is to start with a magicgui <code>Container</code>, and then walk through the pydantic model fields, adding a new <code>Container</code> when encountering a nested pydantic object or otherwise using <code>get_widget_class</code> to add widgets to the container when the field. For a simple initial pydantic model without nested models, we can just iterate over the <code>.__fields__</code> attribute of the pydantic model:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> pydantic
<span style=color:#f92672>from</span> magicgui <span style=color:#f92672>import</span> widgets
<span style=color:#f92672>from</span> magicgui.type_map <span style=color:#f92672>import</span> get_widget_class

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleModel</span>(pydantic<span style=color:#f92672>.</span>BaseModel):
    field_1: str
    field_2: float
    
container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()

<span style=color:#66d9ef>for</span> field, field_info <span style=color:#f92672>in</span> SimpleModel<span style=color:#f92672>.</span>__fields__<span style=color:#f92672>.</span>items():
    new_widget_class, _ <span style=color:#f92672>=</span> get_widget_class(annotation <span style=color:#f92672>=</span> field_info<span style=color:#f92672>.</span>type_)
    container<span style=color:#f92672>.</span>append(new_widget_class(name<span style=color:#f92672>=</span>field))
    
container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)       
</code></pre></div><p><img src=/images/magicguipydantic/widgets_03.png alt=png></p><p>For a more complex traversal, we&rsquo;ll want to use a recursive function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_pydantic_to_container</span>(py_model, container):
    <span style=color:#75715e># recursively traverse a pydantic model adding widgets to a container. When a nested</span>
    <span style=color:#75715e># pydantic model is encountered, add a new nested container</span>
    <span style=color:#66d9ef>for</span> field, field_def <span style=color:#f92672>in</span> py_model<span style=color:#f92672>.</span>__fields__<span style=color:#f92672>.</span>items():
        ftype <span style=color:#f92672>=</span> field_def<span style=color:#f92672>.</span>type_
        <span style=color:#66d9ef>if</span> isinstance(ftype, pydantic<span style=color:#f92672>.</span>BaseModel) <span style=color:#f92672>or</span> isinstance(ftype, pydantic<span style=color:#f92672>.</span>main<span style=color:#f92672>.</span>ModelMetaclass):
            <span style=color:#75715e># the field is a pydantic class, add a container for it and fill it</span>
            new_widget_cls <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container
            new_widget <span style=color:#f92672>=</span> new_widget_cls(name<span style=color:#f92672>=</span>field_def<span style=color:#f92672>.</span>name)
            add_pydantic_to_container(ftype, new_widget)
        <span style=color:#66d9ef>else</span>:
            <span style=color:#75715e># parse the field, add appropriate widget</span>
            new_widget_cls, ops <span style=color:#f92672>=</span> get_widget_class(None, ftype, dict(name<span style=color:#f92672>=</span>field_def<span style=color:#f92672>.</span>name, value<span style=color:#f92672>=</span>field_def<span style=color:#f92672>.</span>default))
            new_widget <span style=color:#f92672>=</span> new_widget_cls(<span style=color:#f92672>**</span>ops)
            <span style=color:#66d9ef>if</span> isinstance(new_widget, widgets<span style=color:#f92672>.</span>EmptyWidget):
                warnings<span style=color:#f92672>.</span>warn(message<span style=color:#f92672>=</span>f<span style=color:#e6db74>&#34;magicgui could not identify a widget for {py_model}.{field}, which has type {ftype}&#34;</span>)
        container<span style=color:#f92672>.</span>append(new_widget)
</code></pre></div><p>The above function takes in a pydantic model class and a magicgui container and recursively walks through the pydantic model, adding to the container as it goes. It&rsquo;s very similar to the simple example, but when it encounters a pydantic field that is itself a model, it adds a container and then calls itself with the new container and that pydantic field. It also respects the default values of the pydantic fields! And now we can use the above function to map out more complex pydantic models:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComplexModel</span>(pydantic<span style=color:#f92672>.</span>BaseModel):
    simple: SimpleModel
    complex_field: int
    field_with_default: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>
    
container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()   

add_pydantic_to_container(ComplexModel, container)

container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True) 
</code></pre></div><p><img src=/images/magicguipydantic/widgets_04.png alt=png></p><p>And because we were assigning the widget names with the pydantic field names, we can add callbacks easily! For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()   
add_pydantic_to_container(ComplexModel, container)
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>Label(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;result&#34;</span>))

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calculate_result</span>():
    result <span style=color:#f92672>=</span> container<span style=color:#f92672>.</span>simple<span style=color:#f92672>.</span>field_2<span style=color:#f92672>.</span>value <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
    result <span style=color:#f92672>=</span> result <span style=color:#f92672>*</span> container<span style=color:#f92672>.</span>field_with_default<span style=color:#f92672>.</span>value
    container<span style=color:#f92672>.</span>result<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> f<span style=color:#e6db74>&#34;{result}&#34;</span> 
    
    
container<span style=color:#f92672>.</span>simple<span style=color:#f92672>.</span>field_2<span style=color:#f92672>.</span>changed<span style=color:#f92672>.</span>connect(calculate_result)  
container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)
</code></pre></div><p><img src=/images/magicguipydantic/widgets_05.png alt=png></p><h2 id=completing-the-round-trip>completing the round-trip</h2><p>So what I <strong>really</strong> off to do was generate a widget that could instantiate a pydantic class, and at this point we&rsquo;re half-way there. To complete the trip, all we need to do is take our <code>container</code> and traverse it again, pulling out the values that are set so that we can instantiate the pydantic class that was used to generate the widget!</p><p>Going back to the simple case, let&rsquo;s add a callback to generate the class</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleModel</span>(pydantic<span style=color:#f92672>.</span>BaseModel):
    field_1: str
    field_2: float
    
container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()

<span style=color:#66d9ef>for</span> field, field_info <span style=color:#f92672>in</span> SimpleModel<span style=color:#f92672>.</span>__fields__<span style=color:#f92672>.</span>items():
    new_widget_class, _ <span style=color:#f92672>=</span> get_widget_class(annotation <span style=color:#f92672>=</span> field_info<span style=color:#f92672>.</span>type_)
    container<span style=color:#f92672>.</span>append(new_widget_class(name<span style=color:#f92672>=</span>field))
    
<span style=color:#75715e># add a button and a place to display a json from the pydantic model</span>
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>PushButton(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;build&#34;</span>, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Build json&#34;</span>))
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>Label(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;json_display&#34;</span>, value<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>))    

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>display_json</span>():
    
    <span style=color:#75715e># build a dict for args to instantiate</span>
    pydantic_kwargs <span style=color:#f92672>=</span> {}
    <span style=color:#66d9ef>for</span> field <span style=color:#f92672>in</span> SimpleModel<span style=color:#f92672>.</span>__fields__<span style=color:#f92672>.</span>keys():
        field_widget <span style=color:#f92672>=</span> getattr(container, field)
        pydantic_kwargs[field] <span style=color:#f92672>=</span> field_widget<span style=color:#f92672>.</span>value
        
    <span style=color:#75715e># instantiate the model!</span>
    pydantic_model <span style=color:#f92672>=</span> SimpleModel<span style=color:#f92672>.</span>parse_obj(pydantic_kwargs)
    
    <span style=color:#75715e># pull out a json from the model, update the magicgui display</span>
    json_for_display <span style=color:#f92672>=</span> pydantic_model<span style=color:#f92672>.</span>json(indent<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)    
    container<span style=color:#f92672>.</span>json_display<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> json_for_display

container<span style=color:#f92672>.</span>build<span style=color:#f92672>.</span>clicked<span style=color:#f92672>.</span>connect(display_json)  <span style=color:#75715e># note buttons have `clicked` instead of `changed`</span>
container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)  
</code></pre></div><p><img src=/images/magicguipydantic/widgets_06.png alt=png></p><p>And to generalize this to a more complex case, we again can traverse the pydantic object and look for fields that are also pydantic objects. But in this case, we simply add a new dictionary to the <code>pydantic_kwargs</code> dictionary for each new level :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_pydantic_kwargs</span>(container, pydantic_model, pydantic_kwargs):
    <span style=color:#75715e># given a container that was instantiated from a pydantic model, get the arguments</span>
    <span style=color:#75715e># needed to instantiate that pydantic model from the container.</span>

    <span style=color:#75715e># traverse model fields, pull out values from container</span>
    <span style=color:#66d9ef>for</span> field, field_def <span style=color:#f92672>in</span> pydantic_model<span style=color:#f92672>.</span>__fields__<span style=color:#f92672>.</span>items():
        ftype <span style=color:#f92672>=</span> field_def<span style=color:#f92672>.</span>type_
        <span style=color:#66d9ef>if</span> isinstance(ftype, pydantic<span style=color:#f92672>.</span>BaseModel) <span style=color:#f92672>or</span> isinstance(ftype, pydantic<span style=color:#f92672>.</span>main<span style=color:#f92672>.</span>ModelMetaclass):
            <span style=color:#75715e># go deeper</span>
            pydantic_kwargs[field] <span style=color:#f92672>=</span> {} <span style=color:#75715e># new dictionary for the new nest level</span>
            <span style=color:#75715e># any pydantic class will be a container, so pull that out to pass</span>
            <span style=color:#75715e># to the recursive call</span>
            sub_container <span style=color:#f92672>=</span> getattr(container, field_def<span style=color:#f92672>.</span>name)
            get_pydantic_kwargs(sub_container, ftype, pydantic_kwargs[field])
        <span style=color:#66d9ef>else</span>:
            <span style=color:#75715e># not a pydantic class, just pull the field value from the container</span>
            <span style=color:#66d9ef>if</span> hasattr(container, field_def<span style=color:#f92672>.</span>name):
                value <span style=color:#f92672>=</span> getattr(container, field_def<span style=color:#f92672>.</span>name)<span style=color:#f92672>.</span>value
                pydantic_kwargs[field] <span style=color:#f92672>=</span> value
</code></pre></div><p>which we can now use to reverse our complex container construction:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>container <span style=color:#f92672>=</span> widgets<span style=color:#f92672>.</span>Container()   
add_pydantic_to_container(ComplexModel, container)

<span style=color:#75715e># add a button and a place to display a json from the pydantic model</span>
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>PushButton(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;build&#34;</span>, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Build json&#34;</span>))
container<span style=color:#f92672>.</span>append(widgets<span style=color:#f92672>.</span>Label(name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;json_display&#34;</span>, value<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>))    

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>display_json</span>():
    
    <span style=color:#75715e># build a dict for args to instantiate</span>
    pydantic_kwargs <span style=color:#f92672>=</span> {}
    get_pydantic_kwargs(container, ComplexModel, pydantic_kwargs)
    <span style=color:#75715e># instantiate the model!</span>
    pydantic_model <span style=color:#f92672>=</span> ComplexModel<span style=color:#f92672>.</span>parse_obj(pydantic_kwargs)
    
    <span style=color:#75715e># pull out a json from the model, update the magicgui display</span>
    json_for_display <span style=color:#f92672>=</span> pydantic_model<span style=color:#f92672>.</span>json(indent<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)    
    container<span style=color:#f92672>.</span>json_display<span style=color:#f92672>.</span>value <span style=color:#f92672>=</span> json_for_display

container<span style=color:#f92672>.</span>build<span style=color:#f92672>.</span>clicked<span style=color:#f92672>.</span>connect(display_json)  <span style=color:#75715e># note buttons have `clicked` instead of `changed`</span>
container<span style=color:#f92672>.</span>show(run<span style=color:#f92672>=</span>True)  

</code></pre></div><p><img src=/images/magicguipydantic/widgets_07.png alt=png></p><p>A full script capturing everything above is available <a href=https://github.com/chrishavlin/miscellaneous_python/blob/master/src/pydantic_magicgui_roundtrip.py>here</a>.</p><h2 id=final-thoughts>final thoughts</h2><p>The main limitation to the above examples are that I&rsquo;m only handling simple pydantic attributes that are simple types. To handle other attributes (e.g., tuples), I&rsquo;ve played around with <a href=https://napari.org/magicgui/usage/types_widgets.html#register-type>registering new types with magicgui</a> and also modifying the recursive functions to have my own custom mapping from fields to widgets to varying degrees of success. Also note that there may be easier ways (e.g., <a href=https://github.com/hanjinliu/magic-class>magicclass</a> used in combination with magicgui?), but for my application I have separate pydantic model creation and model ingestion methods, so I don&rsquo;t mind the somewhat manual approach here, at least until full pydantic support is in magicgui!</p></div><div class=share-buttons><a class=twitter-share-button href=# title="Share on Twitter" data-url=https://chrishavlin.github.io/post/magicpydantic/ data-text="Autogeneration of magicgui-pydantic widgets"><i class="fab fa-twitter"></i></a><a class=linkedin-share-button href=# title="Share on LinkedIn" data-url=https://chrishavlin.github.io/post/magicpydantic/ data-text="Autogeneration of magicgui-pydantic widgets"><i class="fab fa-linkedin-in"></i></a><a class=facebook-share-button href=# title="Share on Facebook" data-url=https://chrishavlin.github.io/post/magicpydantic/ data-text="Autogeneration of magicgui-pydantic widgets"><i class="fab fa-facebook"></i></a><a class=telegram-share-button href=# title="Share on Telegram" data-url=https://chrishavlin.github.io/post/magicpydantic/ data-text="Autogeneration of magicgui-pydantic widgets"><i class="fab fa-telegram"></i></a><a class=pinterest-share-button href=# title="Share on Pinterest" data-url=https://chrishavlin.github.io/post/magicpydantic/ data-text="Autogeneration of magicgui-pydantic widgets"><i class="fab fa-pinterest"></i></a></div></div></main><footer><div><p>&copy; Chris Havlin 2022
&#183; <a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank>CC BY-SA 4.0</a>
&#183; Build with <a href=https://gohugo.io/ target=_blank>Hugo</a> & <a href=https://themes.gohugo.io/soho/ target=_blank>Soho</a> theme</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin=anonymous></script><script src=/js/jquery.min.js></script><script src=/js/soho.js></script></body></html>