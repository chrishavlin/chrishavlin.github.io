<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.81.0"><title>Order of operations and performance with numpy and Dask &#183; Chris Havlin</title><meta name=description content><meta itemprop=name content="Order of operations and performance with numpy and Dask"><meta itemprop=description content="The past couple days I&rsquo;ve been attending the 2021 Dask Summit and have seen a bunch of interesting and useful talks."><meta itemprop=datePublished content="2021-05-20T10:52:25-04:00"><meta itemprop=dateModified content="2021-05-20T10:52:25-04:00"><meta itemprop=wordCount content="1217"><meta itemprop=image content="https://chrishavlin.github.io/images/turt.png"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chrishavlin.github.io/images/turt.png"><meta name=twitter:title content="Order of operations and performance with numpy and Dask"><meta name=twitter:description content="The past couple days I&rsquo;ve been attending the 2021 Dask Summit and have seen a bunch of interesting and useful talks."><meta property="og:title" content="Order of operations and performance with numpy and Dask"><meta property="og:description" content="The past couple days I&rsquo;ve been attending the 2021 Dask Summit and have seen a bunch of interesting and useful talks."><meta property="og:type" content="article"><meta property="og:url" content="https://chrishavlin.github.io/post/op_order_performance/"><meta property="og:image" content="https://chrishavlin.github.io/images/turt.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-20T10:52:25-04:00"><meta property="article:modified_time" content="2021-05-20T10:52:25-04:00"><meta property="og:site_name" content="Chris Havlin"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://chrishavlin.github.io/#author","name":null,"image":{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png"},"description":" "},{"@type":"WebSite","@id":"https://chrishavlin.github.io/#website","url":"https://chrishavlin.github.io/","name":"Chris Havlin","description":" ","publisher":{"@id":"https://chrishavlin.github.io/#author"},"inLanguage":"en"},{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png","caption":"Chris Havlin"},{"@type":"WebPage","@id":"https://chrishavlin.github.io/post/op_order_performance/#webpage","url":"https://chrishavlin.github.io/post/op_order_performance/","name":"Order of operations and performance with numpy and Dask","isPartOf":{"@id":"https://chrishavlin.github.io/#website"},"about":{"@id":"https://chrishavlin.github.io/#author"},"datePublished":"2021-05-20T10:52:25-04:00","dateModified":"2021-05-20T10:52:25-04:00","description":"The past couple days I\u0026rsquo;ve been attending the 2021 Dask Summit and have seen a bunch of interesting and useful talks.","inLanguage":"en","potentialAction":[{"@type":"ReadAction","target":["https://chrishavlin.github.io/post/op_order_performance/"]}]},{"@type":"Article","isPartOf":{"@id":"https://chrishavlin.github.io/post/op_order_performance/#webpage"},"mainEntityOfPage":{"@id":"https://chrishavlin.github.io/post/op_order_performance/#webpage"},"headline":"Order of operations and performance with numpy and Dask","datePublished":"2021-05-20T10:52:25-04:00","dateModified":"2021-05-20T10:52:25-04:00","publisher":{"@id":"https://chrishavlin.github.io/#author"},"keywords":[],"articleSection":[],"inLanguage":"en","author":{"@type":"Person","name":null},"potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https://chrishavlin.github.io/post/op_order_performance/#comments"]}]}]}</script><link type=text/css rel=stylesheet href=/css/print.css media=print><link type=text/css rel=stylesheet href=/css/poole.css><link type=text/css rel=stylesheet href=/css/hyde.css><style type=text/css>.sidebar{background-color:#3b7044}.read-more-link a{border-color:#3b7044}.read-more-link a:hover{background-color:#3b7044}.pagination li a{color:#3b7044;border:1px solid #3b7044}.pagination li.active a{background-color:#3b7044}.pagination li a:hover{background-color:#3b7044;opacity:.75}footer a,.content a,.related-posts li a:hover{color:#3b7044}</style><link type=text/css rel=stylesheet href=/css/blog.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class=container><div class=sidebar-about><div class=author-image><a href=https://chrishavlin.github.io/><img src=/images/turt.png class="img-circle img-headshot center" alt="Profile Picture"></a></div><h1>Chris Havlin</h1><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://chrishavlin.github.io/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav><section class=social-icons><a href=https://github.com/chrishavlin rel=me title=GitHub target=_blank><i class="fab fa-github" aria-hidden=true></i></a><a href=https://twitter.com/s_i_r_h_c rel=me title=@s_i_r_h_c target=_blank><i class="fab fa-twitter" aria-hidden=true></i></a><a href=https://www.instagram.com/chrishavlin/ rel=me title=@chrishavlin target=_blank><i class="fab fa-instagram" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/christopherhavlin/ rel=me title=Linkedin target=_blank><i class="fab fa-linkedin" aria-hidden=true></i></a></section></div></aside><main class="content container"><div class=post><h1 class=title>Order of operations and performance with numpy and Dask</h1><div class=post-date><time datetime=2021-05-20T10:52:25-0400>May 20, 2021</time> <span class=readtime>&#183; 6 min read</span></div><div><p>The past couple days I&rsquo;ve been attending the 2021 Dask Summit and have seen a bunch of interesting and useful talks. One session, the &ldquo;Hacking Dask&rdquo; tutorial, took a deep dive into various features of the Dask API, some of which I haven&rsquo;t yet spent much time working with. The section on how Dask optimizes a task graph before execution got me thinking about how to optimize some of my own problems in different ways and then in his talk today, Krishan Bhasin dropped this very helpful reminder: &ldquo;Dask does exactly what you ask it to.&rdquo; This note of caution is a reminder to think through your problem before you even start using Dask to see if there are ways to optimize.</p><p>So given all this, I realized that in one my projects, I end up multiplying arrays by constants fairly frequently. And in the case where the ultimate result is a reduced array, then I might be doing some extra work.</p><p>Consider the following simple calculation where we multiple an array of some length by a constant and then take the mean:</p><pre><code>mean(array * constant)
</code></pre><p>If our <code>array</code> has a length <code>N</code>, this will first exceute an element-wise multiplication of <code>constant</code> onto each element in <code>array</code>, so that is <code>N</code> multiplications before finding the mean of the result. But if we think about the reduction operation here (taking the <code>mean</code>), we can write this instead as</p><pre><code>constant * mean(array) 
</code></pre><p>These two calculations are mathematically identical, but in the second case, <code>mean(array)</code> returns a single value, so that the multiplication of the constant adds only a single operation instant of N operations.</p><p>So how big of a difference does this make?</p><h2 id=numpy-baseline>numpy baseline</h2><p>So what we&rsquo;ll do is run through a range of array sizes and compare the time it takes to take the mean first, <code>constant * mean(array)</code> to the time it takes to take the mean second, <code>mean(array*constants)</code>.</p><p>Let&rsquo;s check it out first with vanilla numpy.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>import</span> timeit
<span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
</code></pre></div><p>we&rsquo;ll test a large range of array sizes from 10^5 to 10^9:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>logsize <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>10</span>)
szs <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span><span style=color:#f92672>**</span>logsize
</code></pre></div><p>so here we just loop over the test sizes, build a random array and execute the two operations, recording the elapsed time:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_np <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;mean_first&#39;</span>:np<span style=color:#f92672>.</span>array([]),
              <span style=color:#e6db74>&#39;mean_second&#39;</span>:np<span style=color:#f92672>.</span>array([])}

<span style=color:#66d9ef>for</span> sz_mag <span style=color:#f92672>in</span> logsize:
    a <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>random((<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span>sz_mag, ))
    
    start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
    result <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span>mean() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>
    <span style=color:#75715e># code you want to evaluate</span>
    elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
    results_np[<span style=color:#e6db74>&#39;mean_first&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_np[<span style=color:#e6db74>&#39;mean_first&#39;</span>], elapsed)
    
    
    start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
    result <span style=color:#f92672>=</span> (a<span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>)<span style=color:#f92672>.</span>mean()     
    elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
    results_np[<span style=color:#e6db74>&#39;mean_second&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_np[<span style=color:#e6db74>&#39;mean_second&#39;</span>], elapsed)
        
    <span style=color:#66d9ef>del</span> a
    
    
</code></pre></div><p>and a couple of helpful functions to plot results that will get re-used:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>plot_results</span>(results, xlabl <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;array size&#34;</span>, title<span style=color:#f92672>=</span>None):
    f <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>12</span>,<span style=color:#ae81ff>5</span>))
    
    ax1 <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>1</span>)
    plt<span style=color:#f92672>.</span>plot(szs, results[<span style=color:#e6db74>&#39;mean_first&#39;</span>], label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mean first&#39;</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
    plt<span style=color:#f92672>.</span>plot(szs, results[<span style=color:#e6db74>&#39;mean_second&#39;</span>],label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mean second&#39;</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
    plt<span style=color:#f92672>.</span>legend()
    ax1<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;both&#39;</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
    plt<span style=color:#f92672>.</span>xlabel(xlabl, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
    plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#34;time (s)&#34;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
    ax2 <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplot(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>)
    plt<span style=color:#f92672>.</span>loglog(szs, results[<span style=color:#e6db74>&#39;mean_first&#39;</span>], label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mean first&#39;</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
    plt<span style=color:#f92672>.</span>loglog(szs, results[<span style=color:#e6db74>&#39;mean_second&#39;</span>],label<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mean second&#39;</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
    plt<span style=color:#f92672>.</span>xlabel(xlabl)
    ax2<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;both&#39;</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
    
    <span style=color:#66d9ef>if</span> title:
        f<span style=color:#f92672>.</span>suptitle(title, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
    <span style=color:#66d9ef>return</span> f

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>plot_ratio</span>(results,title<span style=color:#f92672>=</span>None):
    f <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure()
    plt<span style=color:#f92672>.</span>semilogx(szs, 
             results[<span style=color:#e6db74>&#39;mean_second&#39;</span>]<span style=color:#f92672>/</span>results[<span style=color:#e6db74>&#39;mean_first&#39;</span>],
             color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;k&#39;</span>,
             marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
    plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#39;chunk size&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
    plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#39;mean second / mean first&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
    plt<span style=color:#f92672>.</span>gca()<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;both&#39;</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
    <span style=color:#66d9ef>if</span> title:
        f<span style=color:#f92672>.</span>suptitle(title,fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_np, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;numpy&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_8_0.png alt=png></p><p>Ok, so we see our expected result: taking the mean first and then multiply is faster since there are fewer operations. The ratio of the two curves shows that taking the mean first is about 4 times faster.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_ratio(results_np, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;numpy&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_10_0.png alt=png></p><h2 id=dask>Dask</h2><p>Now, things get a little more interesting with Dask.</p><p>Let&rsquo;s say we have a random array with 10 chunks:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> dask.array <span style=color:#f92672>as</span> da
a <span style=color:#f92672>=</span> da<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>random((<span style=color:#ae81ff>100</span>_000, ), chunks<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>_000)
a
</code></pre></div><p>We can actually visualize the difference in the two operations by looking at the Dask task graph.</p><p>Here&rsquo;s the case where we take the mean after multiplying:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>mean_second <span style=color:#f92672>=</span> (<span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> a)<span style=color:#f92672>.</span>mean()
mean_second<span style=color:#f92672>.</span>visualize()
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_14_0.png alt=png></p><p>So we see that for each <code>random_sample</code> chunk, we have a <code>mul</code> step, where we do an element-wise multiplication on each chunk. The <code>mean</code> call then reduces and aggregates by-chunk to eventually get the mean.</p><p>Ok, so let&rsquo;s take the mean first:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>mean_first <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span>mean() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>
mean_first<span style=color:#f92672>.</span>visualize()
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_16_0.png alt=png></p><p>and we can see that the <code>mul</code> operation has been removed from the individual chunk step out to the top, final task.</p><p>Ok, so let&rsquo;s actually compute our different graphs and check out the difference in speed.</p><p>We&rsquo;ll actually drop our test in a function so that we can run multiple tests varying the chunksize:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_dask_test</span>(logsize, chunksize<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>_000):
    results_dask <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;mean_first&#39;</span>:np<span style=color:#f92672>.</span>array([]),
                  <span style=color:#e6db74>&#39;mean_second&#39;</span>:np<span style=color:#f92672>.</span>array([])}

    <span style=color:#66d9ef>for</span> sz_mag <span style=color:#f92672>in</span> logsize:
        a <span style=color:#f92672>=</span> da<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>random((<span style=color:#ae81ff>10</span><span style=color:#f92672>**</span>sz_mag, ),chunks<span style=color:#f92672>=</span>chunksize)

        result <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span>mean() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>    
        start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
        result_computed <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>compute()
        elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
        results_dask[<span style=color:#e6db74>&#39;mean_first&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_dask[<span style=color:#e6db74>&#39;mean_first&#39;</span>], elapsed)

        result <span style=color:#f92672>=</span> (a<span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>)<span style=color:#f92672>.</span>mean() 
        start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
        result_computed <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>compute()
        elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
        results_dask[<span style=color:#e6db74>&#39;mean_second&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_dask[<span style=color:#e6db74>&#39;mean_second&#39;</span>], elapsed)

    <span style=color:#66d9ef>return</span> results_dask
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask <span style=color:#f92672>=</span> run_dask_test(logsize)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dask, chunk size = 1e4&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_20_0.png alt=png></p><p>At first glance, it appears that Dask is magic! Our two approaches now have virtually the same execution time! But wait&mldr; let&rsquo;s think for a minute here. The difference in number of operations is coming from our element-wise multiplication. In this case, though, the element-wise multiplication is applied to each <strong>chunk</strong> of the array, which then runs through the <code>mean</code> aggregation and reduction. So then the number of operations before we start the reduction step actually depends on the size of our chunks, not the total size of the array!</p><p>So let&rsquo;s increase our chunk size a few times and see what happens:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask_big_chunks <span style=color:#f92672>=</span> run_dask_test(logsize, chunksize<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>_000)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask_big_chunks, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dask, chunk size = 1e5&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_23_0.png alt=png></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask_bigger_chunks <span style=color:#f92672>=</span> run_dask_test(logsize, chunksize<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>_000_000)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask_bigger_chunks, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dask, chunk size = 1e6&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_25_0.png alt=png></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask_even_bigger_chunks <span style=color:#f92672>=</span> run_dask_test(logsize, chunksize<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>_000_000)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask_even_bigger_chunks, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dask, chunk size = 1e7&#34;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_27_0.png alt=png></p><p>So as we get to larger chunk sizes, we start to see a difference in our two methods. Let&rsquo;s re-write our test function to vary the chunk size:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_dask_test_vary_chunks</span>(logsize, array_size<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>_000_000):
    results_dask <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;mean_first&#39;</span>:np<span style=color:#f92672>.</span>array([]),
                  <span style=color:#e6db74>&#39;mean_second&#39;</span>:np<span style=color:#f92672>.</span>array([])}

    <span style=color:#66d9ef>for</span> sz_mag <span style=color:#f92672>in</span> logsize:
        chunksize<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span><span style=color:#f92672>**</span>sz_mag
        a <span style=color:#f92672>=</span> da<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>random((array_size, ),chunks<span style=color:#f92672>=</span>chunksize)

        result <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span>mean() <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>    
        start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
        result_computed <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>compute()
        elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
        results_dask[<span style=color:#e6db74>&#39;mean_first&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_dask[<span style=color:#e6db74>&#39;mean_first&#39;</span>], elapsed)

        result <span style=color:#f92672>=</span> (a<span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>)<span style=color:#f92672>.</span>mean() 
        start_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer()
        result_computed <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>compute()
        elapsed <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>default_timer() <span style=color:#f92672>-</span> start_time
        results_dask[<span style=color:#e6db74>&#39;mean_second&#39;</span>]<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>append(results_dask[<span style=color:#e6db74>&#39;mean_second&#39;</span>], elapsed)

    <span style=color:#66d9ef>return</span> results_dask
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask_vary_chunks <span style=color:#f92672>=</span> run_dask_test_vary_chunks(logsize, array_size<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>_000_000)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask_vary_chunks,xlabl<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;chunk size&#39;</span>,title<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dask, array size 1e8&#39;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_31_0.png alt=png></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_ratio(results_dask_vary_chunks,title<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dask, array size 1e9&#39;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_32_0.png alt=png></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>results_dask_vary_chunks <span style=color:#f92672>=</span> run_dask_test_vary_chunks(logsize, array_size<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>_000_000_000)
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_results(results_dask_vary_chunks,xlabl<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;chunk size&#39;</span>,title<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dask, array size 1e9&#39;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_34_0.png alt=png></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plot_ratio(results_dask_vary_chunks,title<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;dask, array size 1e10&#39;</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_35_0.png alt=png></p><p>Now we see that taking the mean first is generally faster &ndash; it <strong>is</strong> perhaps a little surprising that the speedup is not as pronounced as the pure numpy operation. Even at the limit where have a chunksize of 1e9, so that our Dask arrays are single chunks, the two approaches only differ by a factor of 1.3. But this is because doing the calculation in Dask adds an overhead performance hit so that the absolute value of the speedup from taking the mean first is smaller relative to the total execution time.</p><p>In terms of absolute difference, we see an order of 1 second:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>f <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure()
plt<span style=color:#f92672>.</span>semilogx(szs, 
         results_dask_vary_chunks[<span style=color:#e6db74>&#39;mean_second&#39;</span>] <span style=color:#f92672>-</span> results_dask_vary_chunks[<span style=color:#e6db74>&#39;mean_first&#39;</span>],
         color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;k&#39;</span>,
         marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;.&#39;</span>)
plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#39;chunk size&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
plt<span style=color:#f92672>.</span>ylabel(<span style=color:#e6db74>&#39;mean second - mean first (s)&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
plt<span style=color:#f92672>.</span>gca()<span style=color:#f92672>.</span>tick_params(axis<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;both&#39;</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>)
f<span style=color:#f92672>.</span>suptitle(<span style=color:#e6db74>&#34;dask, array size 1e10&#34;</span>,fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>14</span>)
</code></pre></div><p><img src=/images/op_order_performance_files/op_order_performance_37_1.png alt=png></p><p>So overall, a difference of about 1 second is maybe not that big of a deal, but if your task graph has a bunch of operations that could be moved to after-reduction steps, re-arranging the order of operations could save you some computation time!</p></div><div class=share-buttons><a class=twitter-share-button href=# title="Share on Twitter" data-url=https://chrishavlin.github.io/post/op_order_performance/ data-text="Order of operations and performance with numpy and Dask"><i class="fab fa-twitter"></i></a><a class=linkedin-share-button href=# title="Share on LinkedIn" data-url=https://chrishavlin.github.io/post/op_order_performance/ data-text="Order of operations and performance with numpy and Dask"><i class="fab fa-linkedin-in"></i></a><a class=facebook-share-button href=# title="Share on Facebook" data-url=https://chrishavlin.github.io/post/op_order_performance/ data-text="Order of operations and performance with numpy and Dask"><i class="fab fa-facebook"></i></a><a class=telegram-share-button href=# title="Share on Telegram" data-url=https://chrishavlin.github.io/post/op_order_performance/ data-text="Order of operations and performance with numpy and Dask"><i class="fab fa-telegram"></i></a><a class=pinterest-share-button href=# title="Share on Pinterest" data-url=https://chrishavlin.github.io/post/op_order_performance/ data-text="Order of operations and performance with numpy and Dask"><i class="fab fa-pinterest"></i></a></div></div></main><footer><div><p>&copy; Chris Havlin 2023
&#183; <a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank>CC BY-SA 4.0</a>
&#183; Build with <a href=https://gohugo.io/ target=_blank>Hugo</a> & <a href=https://themes.gohugo.io/soho/ target=_blank>Soho</a> theme</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin=anonymous></script><script src=/js/jquery.min.js></script><script src=/js/soho.js></script></body></html>