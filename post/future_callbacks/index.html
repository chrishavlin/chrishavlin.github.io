<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.81.0"><title>Plotting Dask Futures &#183; Chris Havlin</title><meta name=description content><meta itemprop=name content="Plotting Dask Futures"><meta itemprop=description content="In working on some yt-dask refactoring a question came up as to whether or not we could return data from distributed dask workflows as it completes and do something with it."><meta itemprop=datePublished content="2021-06-15T17:35:25-05:00"><meta itemprop=dateModified content="2021-06-15T17:35:25-05:00"><meta itemprop=wordCount content="370"><meta itemprop=image content="https://chrishavlin.github.io/images/turt.png"><meta itemprop=keywords content="code,dask,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chrishavlin.github.io/images/turt.png"><meta name=twitter:title content="Plotting Dask Futures"><meta name=twitter:description content="In working on some yt-dask refactoring a question came up as to whether or not we could return data from distributed dask workflows as it completes and do something with it."><meta property="og:title" content="Plotting Dask Futures"><meta property="og:description" content="In working on some yt-dask refactoring a question came up as to whether or not we could return data from distributed dask workflows as it completes and do something with it."><meta property="og:type" content="article"><meta property="og:url" content="https://chrishavlin.github.io/post/future_callbacks/"><meta property="og:image" content="https://chrishavlin.github.io/images/turt.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-06-15T17:35:25-05:00"><meta property="article:modified_time" content="2021-06-15T17:35:25-05:00"><meta property="og:site_name" content="Chris Havlin"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://chrishavlin.github.io/#author","name":null,"image":{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png"},"description":" "},{"@type":"WebSite","@id":"https://chrishavlin.github.io/#website","url":"https://chrishavlin.github.io/","name":"Chris Havlin","description":" ","publisher":{"@id":"https://chrishavlin.github.io/#author"},"inLanguage":"en"},{"@type":"ImageObject","url":"https://chrishavlin.github.io/images/turt.png","caption":"Chris Havlin"},{"@type":"WebPage","@id":"https://chrishavlin.github.io/post/future_callbacks/#webpage","url":"https://chrishavlin.github.io/post/future_callbacks/","name":"Plotting Dask Futures","isPartOf":{"@id":"https://chrishavlin.github.io/#website"},"about":{"@id":"https://chrishavlin.github.io/#author"},"datePublished":"2021-06-15T17:35:25-05:00","dateModified":"2021-06-15T17:35:25-05:00","description":"In working on some yt-dask refactoring a question came up as to whether or not we could return data from distributed dask workflows as it completes and do something with it.","inLanguage":"en","potentialAction":[{"@type":"ReadAction","target":["https://chrishavlin.github.io/post/future_callbacks/"]}]},{"@type":"Article","isPartOf":{"@id":"https://chrishavlin.github.io/post/future_callbacks/#webpage"},"mainEntityOfPage":{"@id":"https://chrishavlin.github.io/post/future_callbacks/#webpage"},"headline":"Plotting Dask Futures","datePublished":"2021-06-15T17:35:25-05:00","dateModified":"2021-06-15T17:35:25-05:00","publisher":{"@id":"https://chrishavlin.github.io/#author"},"keywords":["code","dask"],"articleSection":["demo","tutorials"],"inLanguage":"en","author":{"@type":"Person","name":null},"potentialAction":[{"@type":"CommentAction","name":"Comment","target":["https://chrishavlin.github.io/post/future_callbacks/#comments"]}]}]}</script><link type=text/css rel=stylesheet href=/css/print.css media=print><link type=text/css rel=stylesheet href=/css/poole.css><link type=text/css rel=stylesheet href=/css/hyde.css><style type=text/css>.sidebar{background-color:#3b7044}.read-more-link a{border-color:#3b7044}.read-more-link a:hover{background-color:#3b7044}.pagination li a{color:#3b7044;border:1px solid #3b7044}.pagination li.active a{background-color:#3b7044}.pagination li a:hover{background-color:#3b7044;opacity:.75}footer a,.content a,.related-posts li a:hover{color:#3b7044}</style><link type=text/css rel=stylesheet href=/css/blog.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin=anonymous><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><body><aside class=sidebar><div class=container><div class=sidebar-about><div class=author-image><a href=https://chrishavlin.github.io/><img src=/images/turt.png class="img-circle img-headshot center" alt="Profile Picture"></a></div><h1>Chris Havlin</h1><p class=lead></p></div><nav><ul class=sidebar-nav><li><a href=https://chrishavlin.github.io/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li></ul></nav><section class=social-icons><a href=https://github.com/chrishavlin rel=me title=GitHub target=_blank><i class="fab fa-github" aria-hidden=true></i></a><a href=https://twitter.com/s_i_r_h_c rel=me title=@s_i_r_h_c target=_blank><i class="fab fa-twitter" aria-hidden=true></i></a><a href=https://www.instagram.com/chrishavlin/ rel=me title=@chrishavlin target=_blank><i class="fab fa-instagram" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/christopherhavlin/ rel=me title=Linkedin target=_blank><i class="fab fa-linkedin" aria-hidden=true></i></a></section></div></aside><main class="content container"><div class=post><h1 class=title>Plotting Dask Futures</h1><div class=post-date><time datetime=2021-06-15T17:35:25-0500>Jun 15, 2021</time> <span class=readtime>&#183; 2 min read</span></div><div><p>In working on some yt-dask refactoring a question came up as to whether or not we could return data from distributed dask workflows as it completes and do something with it. For example, if we&rsquo;re building a profile plot (a souped up histogram of sorts), can we update our bin statistics as data chunks get read in? I&rsquo;ve mostly been concentrating on reading in particle data into delayed <code>dask.array</code> objects using <code>dask.delayed</code> and <code>dask.compute</code>, but after a bit of digging it turns out it&rsquo;s pretty easy to add callbacks to dask tasks submitted to a client.</p><p>When you spin up a dask client,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> dask.distributed <span style=color:#f92672>import</span> Client
client <span style=color:#f92672>=</span> Client()
</code></pre></div><p>and submit some task to call a function, <code>func_handle</code>, with an argument, <code>func_arg</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>do_a_thing <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>submit(func_handle, func_arg)
</code></pre></div><p>you get back a <a href=https://docs.dask.org/en/latest/futures.html>Future</a>. It turns out that there is a context manager, <code>dask.distributed.as_completed</code>, that let&rsquo;s you write code to operate on the results of a future as it comes back (<a href=https://docs.dask.org/en/latest/futures.html#waiting-on-futures>link to dask docs</a>). So I spent a little time fiddling with getting a <code>matplotlib</code> figure to dynamically update as dask futures return. Turned out to be straightforward and might be useful for understanding how to add more complex callbacks in dask workflows!</p><p>First, let&rsquo;s import everything, set our <code>matplotlib</code> backend to <code>notebook</code> (so that our later calls to draw our <code>matplotlib</code> canvas are rendered immediately) and spin up a dask client:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> dask.distributed <span style=color:#f92672>import</span> Client, as_completed
<span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
<span style=color:#f92672>import</span> time

<span style=color:#f92672>%</span>matplotlib notebook

client <span style=color:#f92672>=</span> Client()
</code></pre></div><p>So now let&rsquo;s define the function that we&rsquo;ll submit to our client:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>)
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dy</span>(timedelay):
    time<span style=color:#f92672>.</span>sleep(timedelay)
    <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>rand(x<span style=color:#f92672>.</span>shape[<span style=color:#ae81ff>0</span>])
</code></pre></div><p>this function represents an expensive computation that we want to visualize as it returns. In the following cell, the call to <code>futures = client.map(dy, np.random.rand(30))</code> submits 30 jobs to our client with a random delay between 0 and 1 seconds. Using the <code>as_completed</code> context, we&rsquo;ll sum up all of our returned random arrays as they are calculated and plot the current sum:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>futures <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>map(dy, np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>rand(<span style=color:#ae81ff>30</span>))
y <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros(x<span style=color:#f92672>.</span>shape)
f, axs <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(<span style=color:#ae81ff>1</span>)
<span style=color:#66d9ef>for</span> future <span style=color:#f92672>in</span> as_completed(futures):
    dyvals <span style=color:#f92672>=</span> future<span style=color:#f92672>.</span>result()
    y <span style=color:#f92672>+=</span> dyvals         
    axs<span style=color:#f92672>.</span>set_ylim([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>20</span>])
    axs<span style=color:#f92672>.</span>plot(x, y)   
    f<span style=color:#f92672>.</span>canvas<span style=color:#f92672>.</span>draw()
</code></pre></div><p>And here&rsquo;s a video of what it looks like:</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/1ry3bBBO398 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div></div><div><ul class=tags><li><a href=https://chrishavlin.github.io/tags/code/ class=tag-link>code</a></li><li><a href=https://chrishavlin.github.io/tags/dask/ class=tag-link>dask</a></li></ul></div><div class=share-buttons><a class=twitter-share-button href=# title="Share on Twitter" data-url=https://chrishavlin.github.io/post/future_callbacks/ data-text="Plotting Dask Futures"><i class="fab fa-twitter"></i></a><a class=linkedin-share-button href=# title="Share on LinkedIn" data-url=https://chrishavlin.github.io/post/future_callbacks/ data-text="Plotting Dask Futures"><i class="fab fa-linkedin-in"></i></a><a class=facebook-share-button href=# title="Share on Facebook" data-url=https://chrishavlin.github.io/post/future_callbacks/ data-text="Plotting Dask Futures"><i class="fab fa-facebook"></i></a><a class=telegram-share-button href=# title="Share on Telegram" data-url=https://chrishavlin.github.io/post/future_callbacks/ data-text="Plotting Dask Futures"><i class="fab fa-telegram"></i></a><a class=pinterest-share-button href=# title="Share on Pinterest" data-url=https://chrishavlin.github.io/post/future_callbacks/ data-text="Plotting Dask Futures"><i class="fab fa-pinterest"></i></a></div></div></main><footer><div><p>&copy; Chris Havlin 2024
&#183; <a href=https://creativecommons.org/licenses/by-sa/4.0 target=_blank>CC BY-SA 4.0</a>
&#183; Build with <a href=https://gohugo.io/ target=_blank>Hugo</a> & <a href=https://themes.gohugo.io/soho/ target=_blank>Soho</a> theme</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=" crossorigin=anonymous></script><script src=/js/jquery.min.js></script><script src=/js/soho.js></script></body></html>